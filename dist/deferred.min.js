/**
 * Deferred
 * Version: 1.3.2
 * Author: Dmitry Shimkin <dmitryshimkin@gmail.com>
 * License: MIT
 * https://github.com/dmitryshimkin/deferred
 */
!function(global,factory){"object"==typeof exports&&"undefined"!=typeof module?module.exports=factory():"function"==typeof define&&define.amd?define(factory):global.Deferred=factory()}(this,function(){"use strict";function indexOf(promises,promise){for(var i=promises.length;i--;)if(promises[i]===promise)return i;return-1}function isDeferred(arg){return arg instanceof Deferred$1}function processChild(parentPromise,child){var x,error,value=parentPromise.value,isResolved=2===parentPromise._state,fn=isResolved?child.onResolve:child.onReject,hasHandler="function"==typeof fn;if(!hasHandler)return void(isResolved?child.deferred.resolve(value):child.deferred.reject(value));try{x=fn.call(child.ctx,value)}catch(err){error=err}void 0!==error?child.deferred.reject(error):child.deferred.resolve(x)}function Promise(){this.value=void 0,this._state=0,this.cid="cid"+counter,counter++}function always(arg,ctx){return isDeferred(arg)?this.done(function(value){arg.resolve(value)}).fail(function(reason){arg.reject(reason)}):this.done(arg,ctx).fail(arg,ctx),this}function done(arg,ctx){var state=this._state,isDfd=isDeferred(arg);return 2===state?(isDfd?arg.resolve(this.value):arg.call(ctx,this.value),this):(0===state&&(isDfd?this.done(function(value){arg.resolve.call(arg,value)}):addCallback(this,"_doneCallbacks",{fn:arg,ctx:ctx})),this)}function fail(arg,ctx){var state=this._state,isDfd=isDeferred(arg);return 3===state?(isDfd?arg.reject(this.value):arg.call(ctx,this.value),this):(0===state&&(isDfd?this.fail(function(reason){arg.reject(reason)}):addCallback(this,"_failCallbacks",{fn:arg,ctx:ctx})),this)}function isPending(){return this._state<=1}function isRejected(){return 3===this._state}function isResolved(){return 2===this._state}function then(onResolve,onReject,argCtx){var argsCount=arguments.length;return 2===argsCount&&("object"==typeof onReject?(argCtx=onReject,onReject=null):argCtx=this),_then(this,onResolve,onReject,argCtx)}function _then(parentPromise,onResolve,onReject,ctx){var childDeferred=new Deferred$1;if(parentPromise.isResolved()&&"function"!=typeof onResolve)return childDeferred.resolve(parentPromise.value),childDeferred.promise;if(parentPromise.isRejected()&&"function"!=typeof onReject)return childDeferred.reject(parentPromise.value),childDeferred.promise;var child=new Child(childDeferred,onResolve,onReject,ctx);return parentPromise.isPending()?addChild(parentPromise,child):processChild(parentPromise,child),childDeferred.promise}function Child(dfd,onResolve,onReject,ctx){this.deferred=dfd,this.onResolve=onResolve,this.onReject=onReject,this.ctx=ctx}function addChild(parentPromise,child){parentPromise._children?parentPromise._children.push(child):parentPromise._children=[child]}function _catch(onReject,ctx){return this.then(null,onReject,ctx)}function addCallback(promise,key,obj){promise[key]?promise[key].push(obj):promise[key]=[obj]}function Deferred$1(){this.promise=new Promise}function reject(reason){return 0!==this.promise._state?this:rejectWithReason(this,reason)}function resolve(x){var dfd=this,promise=this.promise;return 0!==promise._state?dfd:x===this||x===promise?rejectWithSameArgError(dfd):x instanceof Promise?resolveWithPromise(dfd,x):resolveWithValue(dfd,x)}function rejectWithReason(dfd,reason){var promise=dfd.promise;return promise._state=3,promise.value=reason,runCallbacks(promise._failCallbacks,reason),processChildren(dfd),cleanUpPromise(promise),dfd}function rejectWithSameArgError(dfd){var err=new TypeError("Promise and argument refer to the same object");return dfd.reject(err),dfd}function resolveWithPromise(dfd,promise){return lockPromise(dfd.promise),promise.done(function(xValue){dfd.promise._state=0,resolveWithValue(dfd,xValue)}).fail(function(xReason){dfd.promise._state=0,rejectWithReason(dfd,xReason)}),dfd}function resolveWithValue(dfd,value){return dfd.promise._state=2,dfd.promise.value=value,runCallbacks(dfd.promise._doneCallbacks,value),processChildren(dfd),cleanUpPromise(dfd.promise),dfd}function processChildren(dfd){var children=dfd.promise._children;if(children)for(var i=0;i<children.length;i++)processChild(dfd.promise,children[i])}function runCallbacks(callbacks,value){if(callbacks)for(var i=0;i<callbacks.length;i++)runCallback(callbacks[i],value)}function runCallback(callback,value){try{callback.fn.call(callback.ctx,value)}catch(err){throwAsync(err)}}function throwAsync(err){setTimeout(function(){throw err},0)}function isPromise(arg){return arg instanceof Promise}function isThenable(arg){return null!==arg&&"object"==typeof arg&&"function"==typeof arg.then}function cleanUpPromise(promise){promise._doneCallbacks=null,promise._failCallbacks=null}function lockPromise(promise){promise._state=1}function all(promises){var dfd=new Deferred$1;if(!promises)return dfd.promise;var i,l,values=new Array(promises.length),pendingCount=0;for(i=0,l=promises.length;l>i;i++){if(promises[i].isRejected())return dfd.reject(promises[i].value),dfd.promise;promises[i].isResolved()?values[i]=promises[i].value:(pendingCount++,promises[i].fail(function(reason){dfd.reject(reason)}),promises[i].done(function(value){var index=indexOf(promises,this);values[index]=value,pendingCount--,0===pendingCount&&dfd.resolve(values)},promises[i]))}return pendingCount?dfd.promise:(dfd.resolve(values),dfd.promise)}function race(promises){var dfd=new Deferred$1;if(!promises)return dfd.promise;var i,l,reasons=new Array(promises.length),pendingCount=0;for(i=0,l=promises.length;l>i;i++){if(promises[i].isResolved())return dfd.resolve(promises[i].value),dfd.promise;promises[i].isRejected()?reasons[i]=promises[i].value:(pendingCount++,promises[i].done(function(value){dfd.resolve(value)}),promises[i].fail(function(reason){var index=indexOf(promises,this);reasons[index]=reason,pendingCount--,0===pendingCount&&dfd.reject(reasons)},promises[i]))}return pendingCount?dfd.promise:(dfd.reject(reasons),dfd.promise)}function reject$1(reason){var dfd=new Deferred$1;return dfd.reject(reason),dfd.promise}function resolve$1(x){if(Deferred$1.isPromise(x))return x;if(Deferred$1.isDeferred(x))return x.promise;var dfd=new Deferred$1;return Deferred$1.isThenable(x)?x.then(function(val){dfd.resolve(val)},function(reason){dfd.reject(reason)}):dfd.resolve(x),dfd.promise}var counter=0;return Promise.prototype.always=always,Promise.prototype.done=done,Promise.prototype.fail=fail,Promise.prototype["catch"]=_catch,Promise.prototype.isPending=isPending,Promise.prototype.isResolved=isResolved,Promise.prototype.isRejected=isRejected,Promise.prototype.then=then,Deferred$1.isDeferred=isDeferred,Deferred$1.isPromise=isPromise,Deferred$1.isThenable=isThenable,Deferred$1.prototype.reject=reject,Deferred$1.prototype.resolve=resolve,Deferred$1.all=all,Deferred$1.race=race,Deferred$1.reject=reject$1,Deferred$1.resolve=resolve$1,Deferred$1});